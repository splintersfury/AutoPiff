"""
Maps AutoPiff / IOCTLance findings to exploit primitives and techniques.

Loads exploit_map.yaml and provides lookup by:
  - AutoPiff category + sinks  (patch diff findings)
  - IOCTLance title            (static analysis findings)

Returns a compact dict suitable for embedding in Stage 4 output or
Telegram notifications.
"""

import os
import logging
from typing import Dict, List, Optional

import yaml

logger = logging.getLogger("autopiff.exploit_mapper")


class ExploitMapper:
    """Stateless lookup from finding attributes to exploit context."""

    def __init__(self, map_path: Optional[str] = None):
        if map_path is None:
            map_path = os.path.join(
                os.path.dirname(__file__), '..', '..', 'rules', 'exploit_map.yaml'
            )

        try:
            with open(map_path, 'r') as f:
                data = yaml.safe_load(f)
        except Exception as e:
            logger.warning(f"Could not load exploit_map.yaml: {e}")
            data = {}

        self._vuln_classes = data.get("vuln_classes", {})
        self._primitives = data.get("primitives", {})
        self._techniques = data.get("techniques", {})

        # Build reverse indexes for fast lookup
        self._cat_index: Dict[str, List[str]] = {}   # category -> [vuln_class]
        self._sink_index: Dict[str, List[str]] = {}   # sink -> [vuln_class]
        self._title_index: Dict[str, List[str]] = {}  # ioctlance title -> [vuln_class]

        for vc_name, vc in self._vuln_classes.items():
            for cat in vc.get("autopiff_categories", []):
                self._cat_index.setdefault(cat, []).append(vc_name)
            for sink in vc.get("autopiff_sinks", []):
                self._sink_index.setdefault(sink, []).append(vc_name)
            for title in vc.get("ioctlance_titles", []):
                self._title_index.setdefault(title.lower(), []).append(vc_name)

        logger.info(
            f"ExploitMapper loaded: {len(self._vuln_classes)} vuln classes, "
            f"{len(self._primitives)} primitives, {len(self._techniques)} techniques"
        )

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def map_autopiff(self, category: str, sinks: List[str]) -> Optional[Dict]:
        """Map an AutoPiff finding (category + sinks) to exploit context."""
        candidates = set(self._cat_index.get(category, []))
        for sink in sinks:
            candidates.update(self._sink_index.get(sink, []))

        if not candidates:
            return None

        # Pick the best match: prefer candidates that match BOTH category and sink
        best = None
        best_score = -1
        for vc_name in candidates:
            vc = self._vuln_classes[vc_name]
            score = 0
            if category in vc.get("autopiff_categories", []):
                score += 2
            for sink in sinks:
                if sink in vc.get("autopiff_sinks", []):
                    score += 1
            if score > best_score:
                best_score = score
                best = vc_name

        return self._build_context(best)

    def map_ioctlance(self, title: str) -> Optional[Dict]:
        """Map an IOCTLance vulnerability title to exploit context."""
        matches = self._title_index.get(title.lower(), [])
        if not matches:
            return None
        return self._build_context(matches[0])

    # ------------------------------------------------------------------
    # Internal
    # ------------------------------------------------------------------

    def _build_context(self, vc_name: Optional[str]) -> Optional[Dict]:
        if not vc_name:
            return None

        vc = self._vuln_classes.get(vc_name, {})
        prim_names = vc.get("primitives", [])
        severity = vc.get("severity", "unknown")

        primitives = []
        all_techniques = []
        for pn in prim_names:
            p = self._primitives.get(pn, {})
            tech_names = p.get("techniques", [])
            techs = []
            for tn in tech_names:
                t = self._techniques.get(tn, {})
                tech = {"id": tn, "description": t.get("description", tn)}
                if t.get("min_build"):
                    tech["min_build"] = t["min_build"]
                if t.get("max_build"):
                    tech["max_build"] = t["max_build"]
                if t.get("blocked_by"):
                    tech["blocked_by"] = t["blocked_by"]
                if t.get("note"):
                    tech["note"] = t["note"]
                techs.append(tech)
                all_techniques.append(tech)

            primitives.append({
                "id": pn,
                "description": p.get("description", pn),
                "techniques": techs,
            })

        return {
            "vuln_class": vc_name,
            "severity": severity,
            "primitives": primitives,
            "note": vc.get("note", ""),
        }

    def enrich_deltas(self, deltas: List[Dict]) -> List[Dict]:
        """Add exploit_context to a list of Stage 4 delta dicts in-place."""
        for delta in deltas:
            ctx = self.map_autopiff(
                delta.get("category", ""),
                delta.get("sinks", []),
            )
            if ctx:
                delta["exploit_context"] = ctx
        return deltas

    def enrich_ioctlance(self, vulns: List[Dict]) -> List[Dict]:
        """Add exploit_context to a list of IOCTLance vuln dicts in-place."""
        for vuln in vulns:
            ctx = self.map_ioctlance(vuln.get("title", ""))
            if ctx:
                vuln["exploit_context"] = ctx
        return vulns
